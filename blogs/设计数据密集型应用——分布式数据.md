---
title: 《设计数据密集形应用》第二章读书笔记
date: 2023-8-15 16:47:00
tags: [分布式,学习笔记]
category: 分布式

---

# 分布式数据

《设计数据密集型应用》一书第二部分，分布式数据中涉及到了数据的复制,如何分区，分布式事务，讨论了分布式系统的麻烦及解决方案，一致性与共识的认知。



## 复制

复制代表着通过网络连接的多台机器上保留着相同的副本。一般情况下使用复制功能，我们更期望的是：

1.让用户在地理上更接近数据(从而减少延迟)

2.系统的一部分出现故障，系统也能继续工作(提高可用性)

3.伸缩可以接受读请求的机器数量(提高吞吐量)

如果复制的数据不会随着时间而改变，那复制就变得很简单：将数据复制到每节点，仅需一次就好了。但复制的困难往往出现在处理复制数据的**变更**。

本小结将会讨论三种流行的变更复制算法：**单领导者（single leader，单主）**，**多领导者（multi leader，多主）** 和 **无领导者（leaderless，无主）**。几乎所有分布式数据库都使用这三种方法之一。

当然，在复制时也同样进行很多权衡，使用同步复制还是异步复制？如何处理失败的副本？



### 领导者与追随者

存储了数据拷贝的每个节点被称为**副本(replica)**。当多个副本存在时就有出现一个问题：如何确保所有数据都存在副本上？

每一次向数据库的写入操作都需要传播到所有副本上，否则副本数据就不能保持一致。

**基于领导者的复制（leader-based replication）** （也称 **主动/被动（active/passive）** 复制或 **主/从（master/slave）** 复制）

1.在多个副本中选一个副本指定其为**领导者(leader)**,有时也被称为**主库(master|primary)**。当客户端发送写入请求时，它必须将请求发送给**领导者**，其会将新数据写入其本地存储。

2.其他副本被称为 **追随者（followers）**，亦称为 **只读副本（read replicas）**、**从库（slaves）**、**备库（ secondaries）** 或 **热备（hot-standby）**[1](https://github.com/Vonng/ddia/blob/master/ch5.md#user-content-fn-i-8006e2d5a73957a25f1adcd45244d11b)。每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有的追随者，称之为 **复制日志（replication log）** 或 **变更流（change stream）**。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照与领导者相同的处理顺序来进行所有写入。

3.当客户想要从数据库中读取数据时，它可以向领导者或任一追随者进行查询。但只有领导者才能接受写入操作（从客户端的角度来看从库都是只读的）。

![image-20230815174416749](https://raw.githubusercontent.com/AnAnonymousFriend/images/main/image-20230815174416749.png)

#### 同步复制和异步复制

复制系统的一个重要细节是：复制是 **同步（synchronously）** 发生的还是 **异步（asynchronously）** 发生的。

通常情况下复制的速度相当快：大多数数据库系统能在一秒内完成从库的同步，但它们不能提供复制用时的保证。在某些情况下从库可能落后主库几分钟或者更久：比如从库正在从故障中恢复，系统正在最大容量附近运行，或者当节点间存在网络问题时。

同步复制的优点：从库能保证与主库一致的最新数据副本。如果主库突然失效，我们依然能在从库上找到这些数据。

同步复制的缺点：如果同步从库没有响应(比如从库已经崩溃，或者网络出现故障)，主库就无法处理写入操作。主库会阻止所有写入，一直到从库再次可用。

> 所以将所有从库都设置为同步是不切实际的。因为任何一个节点的中断都会影响到整个系统，这对高可用来说是致命的。
>
> 在现实使用场景，如果在数据库上启用同步复制，通常指其中**一个**从库是同步的，其他从库是异步的。如果该同步从库变得不可用或缓慢，则将一个异步从库改为同步运行。这保证你至少在两个节点上拥有最新的数据副本：主库和同步从库。 这种配置有时也被称为 **半同步（semi-synchronous）**。

通常情况下，基于领导者的复制都配置为完全异步。在这种情况下，如果主库失效且不可恢复，则任何尚未复制给从库的写入都会丢失。这意味着即使已经向客户端确认成功，写入也不能保证是 **持久（Durable）** 的。然而，一个完全异步的配置也有优点：即使所有的从库都落后了，主库也可以继续处理写入。



#### 设置新从库

有时候需要临时设置一个新的从库，可能是负载更大需要增加副本的数量，或者替换掉集群中长期失败的节点。

设置新从库会有如下流程：

1. 在某个时刻获取主库的一致性快照（如果可能，不必锁定整个数据库）。大多数数据库都具有这个功能，因为它是备份必需的。对于某些场景，可能需要第三方工具，例如用于 MySQL 的 innobackupex。
2. 将快照复制到新的从库节点。
3. 从库连接到主库，并拉取快照之后发生的所有数据变更。这要求快照与主库复制日志中的位置精确关联。该位置有不同的名称，例如 PostgreSQL 将其称为 **日志序列号（log sequence number，LSN）**，MySQL 将其称为 **二进制日志坐标（binlog coordinates）**。
4. 当从库处理完快照之后积累的数据变更，我们就说它 **赶上（caught up）** 了主库，现在它可以继续及时处理主库产生的数据变化了。

建立从库这个步骤需要根据不同的数据来进行配置，有些可能是自动化的，有些则需要管理手动操作。



#### 处理节点宕机

##### 从库失效：追赶恢复

在宿主机的本地磁盘中，会记录者从库收到的数据变更日志，如果从库崩溃并重新启动。从库可以从日志中得知，在发生故障之前处理的最后一个事务。因此，从库可以连接到主库，并请求在从库断开期间发生的所有数据变更。当应用完所有这些变更后，它就赶上了主库，并可以像以前一样继续接收数据变更流。

##### 主库失效：故障切换

主库失效处理起来相当棘手：其中一个从库需要被提升为新的主库，需要重新配置客户端，以将它们的写操作发送给新的主库，其他从库需要开始拉取来自新主库的数据变更。这个过程被称为 **故障切换（failover）**。

自动化切换：

1.确认主库失效。可以使用超时机制来确定主库是否挂了，类似于心跳包。

2.选举：剩余副本通过**共识算法**选举出一个新的主库。(也可以事先配置**控制节点**来指定新的主库)

3.重新配置系统以启用新的主库。如果旧主库恢复，让它成为一个从库。

> 故障自动切换过程中会相当麻烦且繁琐，不少运维团队更愿意手动执行故障切换。



#### 复制日志的实现

1.基于语句的复制

主库记录它执行的每个写入请求(语句)并将该语句日志发送给从库。每个从库解析并执行SQL语句，就像直接从客户端收到一样。

但是下列问题会让第一种实现变得数据不一致：

- 任何调用 **非确定性函数（nondeterministic）** 的语句，可能会在每个副本上生成不同的值。例如，使用 `NOW()` 获取当前日期时间，或使用 `RAND()` 获取一个随机数。
- 如果语句使用了 **自增列（auto increment）**，或者依赖于数据库中的现有数据（例如，`UPDATE ... WHERE <某些条件>`），则必须在每个副本上按照完全相同的顺序执行它们，否则可能会产生不同的效果。当有多个并发执行的事务时，这可能成为一个限制。
- 有副作用的语句（例如：触发器、存储过程、用户定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定性的。

> 通常情况下都不会选用这种复制方法



2.传输预写式日志（WAL）

- 对于日志结构存储引擎（请参阅 “[SSTables 和 LSM 树](https://github.com/Vonng/ddia/blob/master/ch3.md#SSTables和LSM树)”），日志是主要的存储位置。日志段在后台压缩，并进行垃圾回收。
- 对于覆写单个磁盘块的 [B 树](https://github.com/Vonng/ddia/blob/master/ch3.md#B树)，每次修改都会先写入 **预写式日志（Write Ahead Log, WAL）**，以便崩溃后索引可以恢复到一个一致的状态。

可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外，主库还可以通过网络将其发送给从库。

通过使用这个日志，从库可以构建一个与主库一模一样的数据结构拷贝。

缺点：日志记录的数据非常底层，可能存在版本不兼容。会对运维团队造成麻烦。



3.逻辑日志复制(基于行)

对复制和存储引擎使用不同的日志格式，这样可以将复制日志从存储引擎的内部实现中解耦出来。这种复制日志被称为逻辑日志（logical log），以将其与存储引擎的（物理）数据表示区分开来。

关系数据库的逻辑日志通常是以行的粒度来描述对数据库表的写入记录的序列：

- 对于插入的行，日志包含所有列的新值。
- 对于删除的行，日志包含足够的信息来唯一标识被删除的行，这通常是主键，但如果表上没有主键，则需要记录所有列的旧值。
- 对于更新的行，日志包含足够的信息来唯一标识被更新的行，以及所有列的新值（或至少所有已更改的列的新值）。

> 修改多行的事务会生成多条这样的日志记录，后面跟着一条指明事务已经提交的记录。 MySQL 的二进制日志(当配置为使用基于行的复制时)使用了这种方法。



4.基于触发器的复制

有一些工具可以通过读取数据库日志，使其他应用程序可以使用数据。或者使用关系数据库自带的功能：触发器和存储过程。

触发器允许将数据更改(写入事务)发生时自动执行自定义应用程序代码注册早数据库系统中，触发器可以将更改记录到一个单独的表中，然后再使用外部应用程序读这个表，再加上一点自定义的逻辑就可以将数据复制到另一个系统中去。

基于触发器的复制通常比其他复制方法具有更高的开销，并且比数据库内置的复制更容易出错，也有很多限制。然而由于其灵活性，它仍然是很有用的。



#### 复制延迟问题

基于领导者的复制要求所有写入都由单个节点处理，但只读查询可以由任何一个副本来处理。所以对于读多写少的场景（Web 上的常见模式），一个有吸引力的选择是创建很多从库，并将读请求分散到所有的从库上去。这样能减小主库的负载，并允许由附近的副本来处理读请求。

在这种读伸缩（read-scaling）的体系结构中，只需添加更多的从库，就可以提高只读请求的服务容量。但是，这种方法实际上只适用于异步复制 —— 如果尝试同步复制到所有从库，则单个节点故障或网络中断将导致整个系统都无法写入。而且节点越多越有可能出现个别节点宕机的情况，所以完全同步的配置将是非常不可靠的。

但是异步会有一个问题，如果从库落后，会导致在某一个时间段存在数据不一致的问题。在正常操作中，**复制延迟**在实际中并不显眼，但是在极端情况下延迟会在几秒到几分钟钟不等。

这会造成三种情况：



1.读已之写

如果用户写入后马上查看数据，新数据可能没来得及到达副本，对于用户而言，看起来好像是刚提交的数据丢失了。

在这种情况下，我们需要 **写后读一致性（read-after-write consistency）**，也称为 **读己之写一致性（read-your-writes consistency）**。这是一个保证，如果用户重新加载页面，他们总会看到他们自己提交的任何更新。它不会对其他用户的写入做出承诺：其他用户的更新可能稍等才会看到。它保证用户自己的输入已被正确保存。

如何在基于领导者的复制系统中实现写后读一致性？文中提供了几种解决：

1.对于**可能用户修改过**的内容，总是从主库读取。这就要求得有办法不通过实际的查询就可以知道用户是否修改了某些东西。例如：总是从主库读取用户自己的档案，如果要读取其他用户的档案就去从库。

2.通过跟踪上次更新时间，在上次更新后的一分钟内从主库读。还可以监控从库的复制延迟，防止向任何滞后主库超过一分钟的从库发出查询。

3.客户端记录最近一次写入的时间戳，系统需要确保从库在处理该用户的读取请求时，该时间戳前的变更都已经传播到了本从库中。如果当前从库不够新，则可以从另一个从库读取，或者等待从库追赶上来。但是使用这个方法的时候要注意：**时钟同步变得至关重要**。

