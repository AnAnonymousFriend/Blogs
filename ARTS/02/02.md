Algorithm:

选择排序是一种灵巧的算法，但是速度并不是很快。

```go
package main

import "fmt"

func main() {
	fmt.Println(selectionSort([]int{5, 3, 6, 2, 10}))
}

// 查找数组中最小的元素
func findSmallest(sum []int) int {
	smallest := sum[0] //存储最小的值
	smallest_index := 0
	for i := 0; i < len(sum); i++ {
		if sum[i] < smallest {
			smallest = sum[i]
			smallest_index = i
		}
	}
	return smallest_index
}

// 选择排序

func selectionSort(sum []int) []int {
	newArr := make([]int, len(sum))

	var newsum = sum
	for i := 0; i < len(sum); i++ {
		// 拿到最小的那个元素的索引
		smallest := findSmallest(sum)
		// 放入新的数组中
		newArr = append(newArr, sum[smallest])
		// 旧数组中删除这个最小元素
		newsum = append(newsum[:smallest], newsum[smallest+1:]...)
	}
	return newArr
}

```

上述代码是选择排序暴力实现的一种方案，没有考虑到空间元素，通过`findSmallest`函数遍历数组，找出最小元素的下标然后放入新数组，再次遍历前剔除最小元素。

这种方案肯定不是最优解，因为交换空间过于频繁，还有一种方式：

```go
// 选择排序
func selectSort(sum []int) {
	if len(sum) == 0 {
		return
	}

	for i := 0; i < len(sum)-1; i++ {
		min := i

		for j := i + 1; j < len(sum); j++ {
      // 第一次循环，min = 0 ,j = 1 判断如果 sum[1] < sum[0] 那么min = 1  
			if sum[j] < sum[min] {
				min = j
			}
      // 第一次循环中，min = j,所以这里不交换元素
			if min != j {
				// 交换元素
				sum[i], sum[min] = sum[min], sum[i]
			}
		}
	}
}
```



```
 Sum = []int{5, 3, 6, 2, 10}
 第一次循环，min = 0 ,j = 1 判断如果 sum[1] < sum[0] 那么min = 1  所以这里不交换元素
 第二次循环，min=1,j = 2 判断 sum[2] < sum[1] 相当于判断
```



选择排序改进了冒泡排序，将交换的次数由 `O(n²)` 减少到 `O(n)`，但是比较的次数仍然是 `O(n²)`。通常认为选择排序在执行效率上是高于冒泡排序的。



Review 是读一篇英文文章
Technique/Tips 是分享一个小技术
Share 是分享一个观点