## 前言

　　本文只是记录踩坑的经过，并不一定提供解决方案，单纯用于个人记录。仅此而已。

## 背景

　　公司现有一款软硬件结合的产品，已在windows上发布生产环境，现需开发Mac版本的客户端。

　　![img](https://img2018.cnblogs.com/blog/1292946/201909/1292946-20190909231159447-730236651.png)

 

 　 从上图可以看出，整个项目思路就是把客户端当成一个小型的服务端，不提供界面，只用于接受web 传来的指令。前端与客户端使用**SignalR进行通讯****，**而客户端主要用于操控硬件。**


## 预想

　　接到开发Mac版的任务时，我的想法是：Python 和 .net core 混合开发，用Python 做Mac 版本的客户端，再将 SignalR 改写成 .net core。

　　当时我考虑的是：1. Mac 本身自带Python2.7，使用Python 打包可以减少用户安装的依赖环境。

   　　　　　　　　　　2. 通讯协议不变，利用.net core 使用**SignalR，**前端基本不用更改，减少了开发时间。

　　　　　　　　　　3.因为Python 我私下看过一点，知道python 能调 C#的dll库，但是没看到能调.net core的，顺便想尝试一下混合开发。

　　这个方案被老板否决了，老板要求用Xamarin开发（**标题上线**）。

　　当时我的内心是万般拒绝的，首先我觉得Xamarin的资料太少，即使微软号称拥有140万的Xamarin开发人员，但在国内使用Xamarin的公司少之又少，况且一般都是开发移动端，开发客户端那就更是凤毛麟角。但凡遇到坑，我都不一定能够踩过去。

　　其次在2020年都要推出.Net 5 的情况下，与其花时间去踩Xamarin的坑，我宁愿用Swift重写一遍。（虽然开发周期肯定来不及）

　　在说明了风险之后，老板大手一挥：“风险我来抗，你只管去做。”

　　老板都这么说了，还能怎么办呢？只好先做了再说。　

   

## 问题一：**Xamarin.Mac 能直接使用SignalR 吗？**

　　答案是可行的。

　　在面向谷歌编程的基础下，我筛选出为数不多涵盖Xamarin.Mac 及 SignalR 的文章

　　通过 https://forums.xamarin.com/discussion/35226/signalr-for-xamarin-mac 这个链接得知，Xamarin.mac 是可以使用SignalR的，并且早在三年前就有人在项目上使用过。

　　四年前有人询问过和我一样的问题，在等待一年后，有人告知他是可行的，并且遗憾地表示他来晚了。

　　显然他试图引导我去 Xamarin store Component 去下载想要的组件，但是我并未搜寻出可用信息。

　　我觉得我要是在下面接着问怎么实现，也许一年后甚至更久才有人引导我具去实现。显然我是没有那么长的开发周期的……

　　虽然他并未提及是怎么实现的。

　　但是至少他告诉我，是可行的。




## 问题二：**Xamarin并未涵盖我需要的引用库**　　

　　依靠着官方文档及旧代码，我开始了我的移植。我发现我缺少了一个库 Microsoft.Owin.Host.HttpListener，在复查了一遍资料以旧代码构建后，我意识到我必须依靠这个Dll 在客户端中开放一个本地端口，从而实现握手连接。

　　问题是Xamarin的Nuget并未找到此包。

　　但是随后，我在查阅Xamarin 文档的时，发现Xamarin有三个不同的目标框架，双击解决方案，打开项目选项，选择常规可以看到。（如下图） ***\*
\****

***\*![img](https://img2018.cnblogs.com/blog/1292946/201909/1292946-20190915213125412-497490575.png)\****

 

 

 

　　***\*![img](https://img2018.cnblogs.com/blog/1292946/201909/1292946-20190915213454793-2126640929.png)\****

 

　　从文档中，我们可以看出，Xamarin.mac Full 使用的是“桌面”版本的子集，与.net Framework4.5及更高版本 几乎完全相同。

　　选择Xamarin.mac Full 后 重新生成解决方案，再次打开Nuget包管理，搜索Dll，成功找到，添加。

　　编译通过，调式模式执行，打开前端测试页面进行连接测试。

　　顺便说明一下，SignalR通讯可以在NetWork 的 WS 中看到传输内容。在Mac 上使用谷歌浏览器会报异常且无法看到传输协议，但奇怪的是并不影响正常通讯，只是无法查看。

　　（PS:SignalR在Windows 7 操作系统，无法在"WS" 中查看传输信息，但在all,XHR 可看到 。经过win10 和 win7 测试对比, 个人猜测：win7 在实现SignalR 通讯机制时会改变一部分协议格式 ，会将websocket变成ajax请求）

　　***\**\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*![img](https://img2018.cnblogs.com/blog/1292946/201909/1292946-20190918230804370-2093982957.png)\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\**\***

 

 

## 问题三：Xamarin **？**

　　在我花了一整天的时间调试客户端与硬件的操控，一个最严重的问题暴露出来：命令执行的时间过长。

　　最开始我以为是前端与客户端的连接断掉了，断点调试之后发现指令发送都是秒发，连接也是稳定的，并未出现断连的情况。

　　在反复断点调试之后，我发现给硬件发指令，只有第一次执行的时候是属于正常范围，第二次执行需要三到五分钟不等。

　　于是我猜测是线程堵塞造成命令执行过慢，我把注意力集中在与硬件通讯的第三方库上：HIdsharp

　　我查了一下HidSharp 的资料后，发现这个库是兼容多个平台的，于是我顺藤摸瓜，直接在Github上找到了它的源码，通过阅读它的源码我发现。它使用了两套不同的线程调用来实现流传输。这个时候我更加笃定我的猜想，我认定是HidSharp 在Mac 上流传输开启了多个线程，并且在调用线程池吞吐率过低造成线程堵塞。

　　接下来三天我都在调试这个“bug"，我查阅了关于线程的资料，开始尝试更改这部分代码。

　　很快地，我意识到我可能走错了方向，我一心认为是线程的问题，但是以我目前的水准我没有解决它的能力。

　　我重新写了一个客户端，选择 .net Framework， 使用一模一样的代码，开始做对比测试。

​		经过对比测试在目标框架为.net Framework 发送指令没有任何问题，无论是响应速度还是命令执行速度……

　　

 

　　

 

 

　　

 

 

 

 



　　

　　

##  

 

 